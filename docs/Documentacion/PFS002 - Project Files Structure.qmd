---
title: "Project Files Structure - SIGEA"
author: "Ordoñez Silva, Yonel Jr."
format: 
    pdf: 
        toc: true
        toc-depth: 3
        toc-title: "Indice"
    html:
        toc-depth: 5
        toc: true
        toc-location: left
        number-sections: false
        toc-expand: true
        toc-title: "Tabla de Contenidos"
    md: 
        toc: true
        number-sections: false
        toc-depth: 5
---

# I. Propuesta de Estructura de Archivos del Proyecto

## 1.1. Estructura General del Proyecto

Debido al cambio de arquitectura, se debe modificar tambien la estructura propuesta.

Para esta nueva estructura, se considera la arquitectura actual del proyecto (ver `ADR002`), Capas + MVC + Clean Architectura, se propone usar una carpeta `modules/` donde cada integrante pueda desarrollar un conjunto de requisitos de forma individual reduciendo los conflictos que puedan llegar a darse. 

El flujo de cambios y versiones se hara a traves de `git flow` en un unico repositorio, pero, a diferencia de la anterior estructura, la actual puede generar mas conflictos, hasta el punto de ocasionar problemas graves si es que la comunicacion entre los integrantes no es la adecuada, por lo que es necesario contar con una persona que maneje y/o gestione los `pull requests`, `merges` con `develop` y `main`, ademas del control de versiones del sistema. Al igual que en el anterior documento (PFS001), cada integrante dispondra de una rama especifica para su modulo y solo tocara lo que le corresponde con constante comunicacion con el encargado del control de versiones.

Si se desea interactuar con otro modulo se tiene que realizar una fusion (`merge`) hacia la rama develop de la rama donde se encuentra desarrollando el modulo solicitante con la rama del modulo objetivo.

Para coordinar los componentes fuera del dominio (`src/main/` o `src/main/java/com/zentry/sysgec`) se realizaran reuniones generales donde se discutira y observara el avance de cada integrante, con el objetivo de poder realizar la orquestacion y configuracion necesarias de acuerdo a la configuracion inidividual de cada modulo desarrollado por cada integrante.

Siguiendo el siguiente esquema:

```bash
[ UI (Capa de presentación) ]
 └── Controlador (C) - Recibe requests del usuario
 └── Modelo (M) - Datos que se muestran (DTOs, ViewModels)

[ Capa de aplicación / casos de uso ]
 └── Orquesta la lógica de negocio
 └── Llama a servicios del dominio

[ Capa de dominio ]
 └── Entidades, lógica de negocio pura
 └── Interfaces (repositorios, servicios)

[ Capa de infraestructura ]
 └── Implementaciones reales: bases de datos, APIs externas, etc.
```

Se planteo la siguiente estructura general para el proyecto:

```bash
app/
└── src/
    ├── main/
    │   ├── java/
    │   │   └── com/zentry/sigea/
    │   │       ├── config/              # Configuración de Spring, Beans, Seguridad, CORS, etc.
    │   │       ├── utils/               # Utilidades genéricas (fechas, strings, etc.)
    │   │       ├── presentation/          # Capa de presentación (UI + Controladores)
    │   │       │   ├── api/            # @RestController comunicacion con frontend
    │   │       │   └── models/         # DTOs y ViewModels que la vista necesita
    │   │       │
    │   │       ├── services/              # Capa de aplicación (Casos de uso)
    │   │       │   ├── usecases/          # Casos de uso concretos
    │   │       │   └── interfaces/        # Interfaces para los servicios del dominio
    │   │       │
    │   │       ├── core/                  # Capa de dominio
    │   │       │   ├── entities/          # Entidades de dominio
    │   │       │   ├── value-objects/     # Objetos de valor (si aplica)
    │   │       │   ├── repositories/      # Interfaces de los repositorios
    │   │       │   └── services/          # Servicios de dominio puros
    │   │       │
    │   │       └── infrastructure/        # Capa de infraestructura
    │   │           ├── repositories/      # Implementaciones de los repositorios
    │   │           ├── database/          # Configuración y acceso a base de datos
    │   │           ├── external-apis/     # Clientes de APIs externas
    │   │           └── config/            # Configuración de infraestructura (env, logger, etc.)
    │   └── resources/
    │       ├── application.properties       # Configuración principal (por defecto)
    │       ├── application.yml              # O alternativa en formato YAML
    │       ├── i18n/                        # Archivos de internacionalización (mensajes por idioma)
    │       │   ├── messages_en.properties
    │       │   ├── messages_es.properties
    │       ├── db/
    │       │   ├── migration/               # Scripts SQL para migraciones (ej: Flyway, Liquibase)
    │       │   │   └── V1__init.sql
    │       │   └── seed/                    # Datos de prueba para poblar la DB
    │       ├── logback-spring.xml           # Configuración del sistema de logs (Logback)
    │       ├── banner.txt                   # Banner que se muestra al arrancar la app
    │       └── META-INF/                    # Archivos especiales como manifest, spring.factories, etc.
    ├── test/
    │   └── java/
    │       └── com/miempresa/myapplication/
    │           ├── presentation/
    │           ├── services/
    │           ├── core/
    │           ├── infrastructure/
    │           └── ...
    └── docs/
```

Una posible mejora que se podria implementar, con el fin de mejorar la organizacion y modularizacion, es añadir en una carpeta `modules/` que contenga cada modulo de requisitos del proyecto; luego dentro de cada modulo estructurar las capas.

```bash
app/
└── src/
    └── main/
        └── java/
            └── com/zentry/sigea/
                │   # Podemos usar modulos para estructurar cada modulo de requisitos
                └── modules/              # Agrupación por módulos funcionales
                    ├── ParticipantsRegGest/    # Modulos de Registro y Gestion de Participantes
                    │   ├── presentation/          # Capa de presentación (UI + Controladores)
                    │   │   ├── controllers/       # @RestController comunicacion con frontend
                    │   │   └── models/        # DTOs y ViewModels que la vista necesita
                    │   │
                    │   ├── services/              # Capa de aplicación (Casos de uso)
                    │   │   ├── usecases/          # Casos de uso concretos
                    │   │   └── interfaces/        # Interfaces para los servicios del dominio
                    │   │
                    │   ├── core/                  # Capa de dominio
                    │   │   ├── entities/          # Entidades de dominio
                    │   │   ├── value-objects/     # Objetos de valor (si aplica)
                    │   │   ├── repositories/      # Interfaces de los repositorios
                    │   │   └── services/          # Servicios de dominio puros
                    │   │
                    │   └── infrastructure/        # Capa de infraestructura
                    │       ├── repositories/      # Implementaciones de los repositorios
                    │       ├── database/          # Configuración y acceso a base de datos
                    │       ├── external-apis/     # Clientes de APIs externas
                    │       └── config/            # Configuración de infraestructura (env, logger, etc.)
                    └── Certification/
                        └── ...
```